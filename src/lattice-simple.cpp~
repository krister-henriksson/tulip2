
#include <iostream>
#include <fstream>
#include <string>
#include <vector>

#include <boost/format.hpp>

#include <cmath>


#include "utils.hpp"
#include "utils-math.hpp"
#include "constants.hpp"
#include "utils-matrix.hpp"
#include "utils-string.hpp"
#include "utils-vector.hpp"
#include "utils-errors.hpp"
#include "utils-linalg.hpp"

#include "compound.hpp"
#include "compoundfit.hpp"
#include "physconst.hpp"
#include "errors.hpp"

#include "lattice-simple.hpp"


using namespace std;
using namespace utils;
using namespace constants;
using namespace physconst;
using boost::format;



bool LatticeSimple::matrix_is_a_symm_op(const Matrix<double> & R){
  int i,j,k,p,q, ts, tt;
  Vector<double> bv, rs, rt, rtt;
  bool found;
  int nfound=0;
  double tol = 1e-5;

  int imin=-2, imax=2;
  int jmin=-2, jmax=2;
  int kmin=-2, kmax=2;
  //cout << "name " << name << endl;

  for (q=0; q<nbasis; ++q){
    //cout << "q nbasis " << q << " " << nbasis << endl;

    //rs = R * (pos[q] - minpos); // transformed
    rs = R * pos[q]; // transformed
    ts = types[q];
    //cout << "R = " << R << endl;

    found = false;
    for (i=imin; i<=imax; ++i){
      for (j=jmin; j<=jmax; ++j){
	for (k=kmin; k<=kmax; ++k){
	  for (p=0; p<nbasis; ++p){
	    //cout << "p nbasis " << p << " " << nbasis << endl;
	    //rtt = i*avec + j*bvec + k*cvec + pos[p] - minpos;
	    rtt = i*avec + j*bvec + k*cvec + pos[p];
	    tt = types[p];
	    rt = rs - rtt;
	  
	    if (tt != ts) continue;

	    if (fp_is_small_tol(rt[0], tol) &&
		fp_is_small_tol(rt[1], tol) &&
		fp_is_small_tol(rt[2], tol)){
	      found=true;
	      nfound++;
	      /*
	      cout << "basis elem " << basis_elems[q] << " " << q
		   << " original basis elem " << basis_elems[p] << " " 
		   << basis_vecs[q] << " is symmetric with " << rtt
		   << "i j k p : "
		   << i << " " << j << " " << k << " " << p
		   << endl;
	      */
	      //i=1; j=1; k=1; p=nbasis;
	    }
	    if (found) break;
	  }
	  if (found) break;
	}
	if (found) break;
      }
      if (found) break;
    }
    
  }

  if (nfound==nbasis) return true;
  else return false;
}


// ########################################################################
// ########################################################################
// ########################################################################
// ########################################################################



void latsymm(Vector<CompoundStructureFit> & cmplist){


  /* Pages 280-3 of Nye:
     Laboratory system: x,y,z
     System used for tensors and matrices: X,Y,Z. These form a Cartesian system.

     Triclinic:
     - no special requirement for primitive vectors

     Monoclinic:
     - Y || y, sometimes: Z || y
     - alpha = gamma = 90 deg, y parallel to 2-fold axis

     Tetragonal, trigonal, hexagonal:
     - Z || z, X || x
     * tetragonal: a=b, alpha = beta = gamma = 90 deg, z parallel to 4-fold axes
     * trigonal: a=b, alpha = beta = 90 deg, gamma = 120 deg, z parallel to 3-fold axis
     * hexagonal: a=b, alpha = beta = 90 deg, gamma = 120 deg, z parallel to 6-fold axis

     Orthorombic and cubic:
     - X || x, Y || y, Z || z
     - alpha = beta = gamma = 90 deg
     * orthorombic: x,y,z parallel to 2-fold axes
     * cubic: x,y,z parallel to cube edges, body diagonals are the 3-fold axes
   */

  Matrix<double> Rx60(3,3,0),  Ry60(3,3,0),  Rz60(3,3,0);
  Matrix<double> Rx90(3,3,0),  Ry90(3,3,0),  Rz90(3,3,0);
  Matrix<double> Rx120(3,3,0), Ry120(3,3,0), Rz120(3,3,0);
  Matrix<double> Rx180(3,3,0), Ry180(3,3,0), Rz180(3,3,0);
  Matrix<double> IRx60(3,3,0),  IRy60(3,3,0),  IRz60(3,3,0);
  Matrix<double> IRx90(3,3,0),  IRy90(3,3,0),  IRz90(3,3,0);
  Matrix<double> IRx120(3,3,0), IRy120(3,3,0), IRz120(3,3,0);
  Matrix<double> IRx180(3,3,0), IRy180(3,3,0), IRz180(3,3,0);
  Matrix<double> Inv(3,3,0);
  Matrix<double> Mx(3,3,0), My(3,3,0), Mz(3,3,0); // same as IR*180(*)

  get_rotation_matrix(Rx60, 2*PI/6, 0);
  get_rotation_matrix(Ry60, 2*PI/6, 1);
  get_rotation_matrix(Rz60, 2*PI/6, 2);
  get_rotation_matrix(Rx90, PI/2, 0);
  get_rotation_matrix(Ry90, PI/2, 1);
  get_rotation_matrix(Rz90, PI/2, 2);
  get_rotation_matrix(Rx120, 2*PI/3, 0);
  get_rotation_matrix(Ry120, 2*PI/3, 1);
  get_rotation_matrix(Rz120, 2*PI/3, 2);
  get_rotation_matrix(Rx180, PI, 0);
  get_rotation_matrix(Ry180, PI, 1);
  get_rotation_matrix(Rz180, PI, 2);

  get_improper_rotation_matrix(IRx60, 2*PI/6, 0);
  get_improper_rotation_matrix(IRy60, 2*PI/6, 1);
  get_improper_rotation_matrix(IRz60, 2*PI/6, 2);
  get_improper_rotation_matrix(IRx90, PI/2, 0);
  get_improper_rotation_matrix(IRy90, PI/2, 1);
  get_improper_rotation_matrix(IRz90, PI/2, 2);
  get_improper_rotation_matrix(IRx120, 2*PI/3, 0);
  get_improper_rotation_matrix(IRy120, 2*PI/3, 1);
  get_improper_rotation_matrix(IRz120, 2*PI/3, 2);
  get_improper_rotation_matrix(IRx180, PI, 0);
  get_improper_rotation_matrix(IRy180, PI, 1);
  get_improper_rotation_matrix(IRz180, PI, 2);

  Inv.elem(0,0) = Inv.elem(1,1) = Inv.elem(2,2) = -1.0; // Same as IR360.

  Mx = IRx180;
  My = IRy180;
  Mz = IRz180;

  Matrix<double> Rdir(3,3,0);
  Vector<double> dir(3,0);
  double th;



  int ic, i, nc=cmplist.size();
  int nbasis;
  int j;
  int imin;
  double sum,summin;
  Matrix<double> A(3,3,0), Ainv(3,3,0);
  Vector<double> b(3,0), x(3,0);
  Vector<double> u1_vec, u2_vec, u3_vec;
  LatticeSimple lattice;
  Vector< Vector<double> > pos, ipos;
  Vector<int> types;
  CompoundStructureFit cmp;
  int i_cub=0, i_hex=0, i_trig=0, i_tetr=0, i_tric=0, i_mon=0, i_or=0;


  for (ic=0; ic<nc; ++ic){
    // Local copy:
    cmp = cmplist[ic];

    nbasis = cmp.nbasis;
    pos  = cmp.basis_vecs;
    ipos = cmp.basis_vecs;
    types = cmp.basis_types;

    for (i=0; i<nbasis; ++i){
      sum = pos[i][0] + pos[i][1] + pos[i][2];
    
      if (i==0 || (i>0 && sum<summin)){
	imin   = i;
	summin = sum;
      }
    }
    /*
    for (i=0; i<nbasis; ++i){
      pos[i][0] -= pos[imin][0];
      pos[i][1] -= pos[imin][1];
      pos[i][2] -= pos[imin][2];
    }
    */

    A.elem(0,0)=cmp.u1_vec[0];
    A.elem(1,0)=cmp.u1_vec[1];
    A.elem(2,0)=cmp.u1_vec[2];
    A.elem(0,1)=cmp.u2_vec[0];
    A.elem(1,1)=cmp.u2_vec[1];
    A.elem(2,1)=cmp.u2_vec[2];
    A.elem(0,2)=cmp.u3_vec[0];
    A.elem(1,2)=cmp.u3_vec[1];
    A.elem(2,2)=cmp.u3_vec[2];

    for (i=0; i<nbasis; ++i){
      b = pos[i];
      A.solve(b,x,Ainv);
      ipos[i] = x;
      for (j=0; j<3; ++j){
	while (ipos[i][j]< 0.0) ipos[i][j]++;
	while (ipos[i][j]>=1.0) ipos[i][j]--;
      }
    }

    lattice.nbasis = nbasis;
    lattice.minpos = pos[imin];
    lattice.origin = pos[imin];
    lattice.avec = cmp.u1_vec;
    lattice.bvec = cmp.u2_vec;
    lattice.cvec = cmp.u3_vec;
    lattice.pbc  = cmp.pbc;
    lattice.types = cmp.basis_types;
    lattice.pos  = pos;
    lattice.ipos  = ipos;
    lattice.csystem = "";
    lattice.csystem_sub = 0;



    // Default value signifying error:
    cmp.csystem_sub=0;

    /*
    cout << "lattice nbasis " << lattice.nbasis << endl;
    cout << "lattice origin " << lattice.origin << endl;
    cout << "lattice avec " << lattice.avec << endl;
    cout << "lattice bvec " << lattice.bvec << endl;
    cout << "lattice cvec " << lattice.cvec << endl;
    cout << "lattice pos " << lattice.pos << endl;
    cout << "lattice pbc " << lattice.pbc << endl;
    cout << "lattice types " << lattice.types << endl;
    */

    string name = cmp.name;


    int sinv=0;
    int s2x=0, s2y=0, s2z=0;
    int s3x=0, s3y=0, s3z=0;
    int s4x=0, s4y=0, s4z=0;
    int s6x=0, s6y=0, s6z=0;
    int smx=0, smy=0, smz=0;
    int sbar3x=0, sbar3y=0, sbar3z=0;
    int sbar4x=0, sbar4y=0, sbar4z=0;
    int sbar6x=0, sbar6y=0, sbar6z=0;
    int s3d111=0, s3dbar111=0, s3d1bar11=0, s3d11bar1=0;
    int s3dbar1bar11=0, s3dbar11bar1=0, s3d1bar1bar1=0, s3dbar1bar1bar1=0;
    int smd110=0, smdbar110=0, smd1bar10=0, smdbar1bar10=0;
    int s2d110=0, s2dbar110=0, s2d1bar10=0, s2dbar1bar10=0;


    if (lattice.matrix_is_a_symm_op(Inv)){ sinv++; cout << "Compound " << name << " has symmetry Inv" << endl; }

    // ***********************************************************************
    // Proper rotations:
    // ***********************************************************************

    if (lattice.matrix_is_a_symm_op(Rx90)){ s4x++; cout << "Compound " << name << " has symmetry Rot x 90deg" << endl; }
    if (lattice.matrix_is_a_symm_op(Ry90)){ s4y++; cout << "Compound " << name << " has symmetry Rot y 90deg" << endl; }
    if (lattice.matrix_is_a_symm_op(Rz90)){ s4z++; cout << "Compound " << name << " has symmetry Rot z 90deg" << endl; }

    if (lattice.matrix_is_a_symm_op(Rx180)){ s2x++; cout << "Compound " << name << " has symmetry Rot x 180deg" << endl; }
    if (lattice.matrix_is_a_symm_op(Ry180)){ s2y++; cout << "Compound " << name << " has symmetry Rot y 180deg" << endl; }
    if (lattice.matrix_is_a_symm_op(Rz180)){ s2z++; cout << "Compound " << name << " has symmetry Rot z 180deg" << endl; }

    if (lattice.matrix_is_a_symm_op(Rx60)){ s6x++; cout << "Compound " << name << " has symmetry Rot x 60deg" << endl; }
    if (lattice.matrix_is_a_symm_op(Ry60)){ s6y++; cout << "Compound " << name << " has symmetry Rot y 60deg" << endl; }
    if (lattice.matrix_is_a_symm_op(Rz60)){ s6z++; cout << "Compound " << name << " has symmetry Rot z 60deg" << endl; }

    if (lattice.matrix_is_a_symm_op(Rx120)){ s3x++; cout << "Compound " << name << " has symmetry Rot x 120deg" << endl; }
    if (lattice.matrix_is_a_symm_op(Ry120)){ s3y++; cout << "Compound " << name << " has symmetry Rot y 120deg" << endl; }
    if (lattice.matrix_is_a_symm_op(Rz120)){ s3z++; cout << "Compound " << name << " has symmetry Rot z 120deg" << endl; }

    if (s6x && s3x) s3x=0; // 6-fold symmetry implies 3-fold symmetry
    if (s6y && s3y) s3y=0; // 6-fold symmetry implies 3-fold symmetry
    if (s6z && s3z) s3z=0; // 6-fold symmetry implies 3-fold symmetry

    if (s4x && s2x) s2x=0; // 4-fold symmetry implies 2-fold symmetry
    if (s4y && s2y) s2y=0; // 4-fold symmetry implies 2-fold symmetry
    if (s4z && s2z) s2z=0; // 4-fold symmetry implies 2-fold symmetry


    // ***********************************************************************
    // Improper rotations (Rotation + inversion in the origin):
    // ***********************************************************************

    if (lattice.matrix_is_a_symm_op(Mx)){ smx++; cout << "Compound " << name << " has symmetry Mx (yz plane)" << endl; }
    if (lattice.matrix_is_a_symm_op(My)){ smy++; cout << "Compound " << name << " has symmetry My (xz plane)" << endl; }
    if (lattice.matrix_is_a_symm_op(Mz)){ smz++; cout << "Compound " << name << " has symmetry Mz (xy plane)" << endl; }

    if (lattice.matrix_is_a_symm_op(IRx90)){ sbar4x++; cout << "Compound " << name << " has symmetry ImpRot x 90deg" << endl; }
    if (lattice.matrix_is_a_symm_op(IRy90)){ sbar4y++; cout << "Compound " << name << " has symmetry ImpRot y 90deg" << endl; }
    if (lattice.matrix_is_a_symm_op(IRz90)){ sbar4z++; cout << "Compound " << name << " has symmetry ImpRot z 90deg" << endl; }

    if (lattice.matrix_is_a_symm_op(IRx180)){ smx++; cout << "Compound " << name << " has symmetry ImpRot x 180deg" << endl; }
    if (lattice.matrix_is_a_symm_op(IRy180)){ smy++; cout << "Compound " << name << " has symmetry ImpRot y 180deg" << endl; }
    if (lattice.matrix_is_a_symm_op(IRz180)){ smz++; cout << "Compound " << name << " has symmetry ImpRot z 180deg" << endl; }

    if (lattice.matrix_is_a_symm_op(IRx60)){ sbar6x++; cout << "Compound " << name << " has symmetry ImpRot x 60deg" << endl; }
    if (lattice.matrix_is_a_symm_op(IRy60)){ sbar6y++; cout << "Compound " << name << " has symmetry ImpRot y 60deg" << endl; }
    if (lattice.matrix_is_a_symm_op(IRz60)){ sbar6z++; cout << "Compound " << name << " has symmetry ImpRot z 60deg" << endl; }

    if (lattice.matrix_is_a_symm_op(IRx120)){ sbar3x++; cout << "Compound " << name << " has symmetry ImpRot x 120deg" << endl; }
    if (lattice.matrix_is_a_symm_op(IRy120)){ sbar3y++; cout << "Compound " << name << " has symmetry ImpRot y 120deg" << endl; }
    if (lattice.matrix_is_a_symm_op(IRz120)){ sbar3z++; cout << "Compound " << name << " has symmetry ImpRot z 120deg" << endl; }

    if (sbar6x && sbar3x) sbar3x=0; // 6-fold symmetry implies 3-fold symmetry
    if (sbar6y && sbar3y) sbar3y=0; // 6-fold symmetry implies 3-fold symmetry
    if (sbar6z && sbar3z) sbar3z=0; // 6-fold symmetry implies 3-fold symmetry

    if (sbar4x && smx) smx=0; // 4-fold symmetry implies 2-fold symmetry
    if (sbar4y && smy) smy=0; // 4-fold symmetry implies 2-fold symmetry
    if (sbar4z && smz) smz=0; // 4-fold symmetry implies 2-fold symmetry

  
    // ***********************************************************************
    // Rotations around cube space diagonals:
    // ***********************************************************************

    dir[0]=1; dir[1]=1; dir[2]=1;
    th = 2*PI/3; get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s3d111++; cout << "Compound " << name << " has symmetry Rot (1,1,1) 120deg" << endl; }

    dir[0]=-1; dir[1]=1; dir[2]=1;
    th = 2*PI/3; get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s3dbar111++; cout << "Compound " << name << " has symmetry Rot (-1,1,1) 120deg" << endl; }

    dir[0]=1; dir[1]=-1; dir[2]=1;
     th = 2*PI/3; get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s3d1bar11++; cout << "Compound " << name << " has symmetry Rot (1,-1,1) 120deg" << endl; }

    dir[0]=1; dir[1]=1; dir[2]=-1;
    th = 2*PI/3; get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s3d11bar1++; cout << "Compound " << name << " has symmetry Rot (1,1,-1) 120deg" << endl; }

    dir[0]=-1; dir[1]=-1; dir[2]=1;
    th = 2*PI/3; get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s3dbar1bar11++; cout << "Compound " << name << " has symmetry Rot (-1,-1,1) 120deg" << endl; }

    dir[0]=-1; dir[1]=1; dir[2]=-1;
    th = 2*PI/3; get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s3dbar11bar1++; cout << "Compound " << name << " has symmetry Rot (-1,1,-1) 120deg" << endl; }

    dir[0]=1; dir[1]=-1; dir[2]=-1;
    th = 2*PI/3; get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s3d1bar1bar1++; cout << "Compound " << name << " has symmetry Rot (1,-1,-1) 120deg" << endl; }

    dir[0]=-1; dir[1]=-1; dir[2]=-1;
    th = 2*PI/3; get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s3dbar1bar1bar1++; cout << "Compound " << name << " has symmetry Rot (-1,-1,-1) 120deg" << endl; }

    // ***********************************************************************
    // Rotations around cube side diagonals:
    // ***********************************************************************

    dir[0]=1; dir[1]=1; dir[2]=0; th = PI;
    get_improper_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ smd110++; cout << "Compound " << name << " has symmetry Imp Rot (1,1,0) 180deg" << endl; }
    get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s2d110++; cout << "Compound " << name << " has symmetry Rot (1,1,0) 180deg" << endl; }

    dir[0]=-1; dir[1]=1; dir[2]=0; th = PI;
    get_improper_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ smdbar110++; cout << "Compound " << name << " has symmetry Imp Rot (-1,1,0) 180deg" << endl; }
    get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s2dbar110++; cout << "Compound " << name << " has symmetry Rot (-1,1,0) 180deg" << endl; }

    dir[0]=1; dir[1]=-1; dir[2]=0; th = PI;
    get_improper_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ smd1bar10++; cout << "Compound " << name << " has symmetry Imp Rot (1,-1,0) 180deg" << endl; }
    get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s2d1bar10++; cout << "Compound " << name << " has symmetry Rot (1,-1,0) 180deg" << endl; }

    dir[0]=-1; dir[1]=-1; dir[2]=0; th = PI;
    get_improper_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ smdbar1bar10++; cout << "Compound " << name << " has symmetry Imp Rot (-1,-1,0) 180deg" << endl; }
    get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s2dbar1bar10++; cout << "Compound " << name << " has symmetry Rot (-1,-1,0) 180deg" << endl; }



    // ***********************************************************************
    // Rotations relevant for trigonal/hexagonal systems:
    // ***********************************************************************
    // Directions: h1:=x, h2, h3, h4:=z
    // Angle between h1 and h2, h2 and h3, and h3 and h1 is 120 deg = 2*PI/3

    // h2:
    dir[0]=cos(120.0/360.0 * 2*PI); dir[1]=sin(120.0/360.0 * 2*PI); dir[2]=0; th = PI;

    int s2dh2=0;
    get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s2dh2++; cout << "Compound " << name << " has symmetry Rot (h2) 180deg" << endl; }

    int smdh2=0;
    get_improper_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ smdh2++; cout << "Compound " << name << " has symmetry Imp Rot (h2) 180deg" << endl; }

    // h3:
    dir[0]=cos(240.0/360.0 * 2*PI); dir[1]=sin(240.0/360.0 * 2*PI); dir[2]=0; th = PI;

    int s2dh3=0;
    get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s2dh3++; cout << "Compound " << name << " has symmetry Rot (h3) 180deg" << endl; }

    int smdh3=0;
    get_improper_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ smdh3++; cout << "Compound " << name << " has symmetry Imp Rot (h3) 180deg" << endl; }

    // Axes orthogonal to h1,h2,h3:
    int iu;

    dir[0]=cos(30.0/360.0 * 2*PI); dir[1]=sin(30.0/360.0 * 2*PI); dir[2]=0; th = PI;

    int s2du1=0;
    get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s2du1++; cout << "Compound " << name << " has symmetry Rot (h1+30deg) 180deg" << endl; }

    int smdu1=0;
    get_improper_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ smdu1++; cout << "Compound " << name << " has symmetry Imp Rot (h1+30deg) 180deg" << endl; }

    dir[0]=cos(90.0/360.0 * 2*PI); dir[1]=sin(90.0/360.0 * 2*PI); dir[2]=0; th = PI;

    int s2du2=0;
    get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s2du2++; cout << "Compound " << name << " has symmetry Rot (h1+90deg) 180deg" << endl; }

    int smdu2=0;
    get_improper_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ smdu2++; cout << "Compound " << name << " has symmetry Imp Rot (h1+90deg) 180deg" << endl; }

    dir[0]=cos(150.0/360.0 * 2*PI); dir[1]=sin(150.0/360.0 * 2*PI); dir[2]=0; th = PI;

    int s2du3=0;
    get_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ s2du3++; cout << "Compound " << name << " has symmetry Rot (h1+150deg) 180deg" << endl; }

    int smdu3=0;
    get_improper_rotation_matrix_u(Rdir, dir, th);
    if (lattice.matrix_is_a_symm_op(Rdir)){ smdu3++; cout << "Compound " << name << " has symmetry Imp Rot (h1+150deg) 180deg" << endl; }





    // Now need to combine operations to figure out which crystal system each compound belongs to

    // Legend:
    // XY: axis X orthogonal to axis Y, rotation axes never parallel
    // Xm: axis X lies in mirror plane
    // X/m: axis X orthogonal to (any vector lying in the) mirror plane

    // Triclinic: only 1 and bar(1) symmetry
    // Monoclinic: 2, m, or 2/m,
    //   class 1 has symmetry axis in Cartesian Y direction
    //   class 2 has symmetry axis in Cartesian Z direction
    // Orthorombic: 222, mm2, or mmm
    // Trigonal:
    //   class 1: 3, bar(3)
    //   class 2: 32, 3m, bar(3) 2/m
    // Tetragonal:
    //   class 1: 4, bar(4), 4/m
    //   class 2: 422, 4mm, bar(4)2m, 4/m 2/m 2/m
    // Hexagonal: 6, bar(6), 6/m, 622, 6mm, bar(6)m2, 6/m 2/m 2/m
    // Cubic: 23, 2/m bar(3), 432, bar(4)3m, 4/m bar(3) 2/m


    /*
    int sn_sum = s2x+s2y+s2z + s3x+s3y+s3z + s4x+s4y+s4z + s6x+s6y+s6z;
    int sbarn_sum = smx+smy+smz + sbar3x+sbar3y+sbar3z + sbar4x+sbar4y+sbar4z + sbar6x+sbar6y+sbar6z;
    int s3d111_sum = s3d111 + s3dbar111 + s3d1bar11 + s3d11bar1
      + s3dbar1bar11 + s3dbar11bar1 + s3d1bar1bar1 + s3dbar1bar1bar1;
    int s2d110_sum = s2d110 + s2dbar110 + s2d1bar10 + s2dbar1bar10;
    int smd110_sum = smd110 + smdbar110 + smd1bar10 + smdbar1bar10;

    int ssum = sn_sum + sbarn_sum + s3d111_sum + s2d110_sum + smd110_sum;
    */

    int s_cubic=0;
    if (s3d111 &&
	s3dbar111 && s3d1bar11 && s3d11bar1 &&
	s3dbar1bar11 && s3dbar11bar1 && s3d1bar1bar1 &&
	s3dbar1bar1bar1)
      s_cubic=1;
      
    cmp.csystem="unknown"; cmp.csystem_sub=0;

    // orthorombic
    if (s2x && s2y && s2z){ // 222
      cmp.csystem="orthorombic"; cmp.csystem_sub=1;
    }
    else if (smx && smy && s2z){ // mm2
      cmp.csystem="orthorombic"; cmp.csystem_sub=2;
    }
    else if (smx && smy && smz){ // mmm
      cmp.csystem="orthorombic"; cmp.csystem_sub=3;
    }
    // cubic
    else if (s2x && s2y && s2z && s_cubic){// 23
      cmp.csystem="cubic"; cmp.csystem_sub=1;
    }
    else if (smx && smy && smz && s_cubic){// m3
      cmp.csystem="cubic"; cmp.csystem_sub=2;
    }
    else if ( (s4x && s4y && s4z) &&
	      s_cubic &&
	      (s2d110 && s2dbar110 && s2d1bar10 && s2dbar1bar10)){ // 432
      cmp.csystem="cubic"; cmp.csystem_sub=3;
    }
    else if ( (sbar4x && sbar4y && sbar4z) &&
	      s_cubic &&
	      (smd110 && smdbar110 && smd1bar10 && smdbar1bar10)){ // bar(4)3m
      cmp.csystem="cubic"; cmp.csystem_sub=4;
    }
    else if ( (smx && smy && smz) &&
	      s_cubic &&
	      (smd110 && smdbar110 && smd1bar10 && smdbar1bar10)){ // m3m
      cmp.csystem="cubic"; cmp.csystem_sub=5;
    }
    // tetragonal
    else if (s4z){// 4
      cmp.csystem="tetragonal"; cmp.csystem_sub=1;
    }
    else if (sbar4z){ // bar(4)
      cmp.csystem="tetragonal"; cmp.csystem_sub=2;
    }
    else if (s4z && (smx && smy)){ // 4/m
      cmp.csystem="tetragonal"; cmp.csystem_sub=3;
    }
    else if (s4z && (s2x && s2y) && (s2d110 && s2d1bar10)){// 422
      cmp.csystem="tetragonal"; cmp.csystem_sub=4;
    }
    else if (s4z && (smx && smy) && (smd110 && smd1bar10)){// 4mm ???
      cmp.csystem="tetragonal"; cmp.csystem_sub=5;
    }
    else if (sbar4z && (s2x && s2y) && (smd110 && smd1bar10)){// bar(4)2m
      cmp.csystem="tetragonal"; cmp.csystem_sub=6;
    }
    else if (sbar4z && (smx && smy) &&
	     (s2x && s2y && smz) &&
	     (s2d110 && s2d1bar10 && smd110 && smd1bar10)){ // 422 ???
      cmp.csystem="tetragonal"; cmp.csystem_sub=7;
    }
    // trigonal
    else if (s3z){// 3
      cmp.csystem="trigonal"; cmp.csystem_sub=1;
    }
    else if (sbar3z){// bar(3)
      cmp.csystem="trigonal"; cmp.csystem_sub=2;
    }
    else if (s3z && (s2x && s2dh2 && s2dh3)){// 32
      cmp.csystem="trigonal"; cmp.csystem_sub=3;
    }
    else if (s3z && (smx && smdh2 && smdh3)){// 3m
      cmp.csystem="trigonal"; cmp.csystem_sub=4;
    }
    else if (sbar3z && (smx && smdh2 && smdh3)){// bar(3) m
      cmp.csystem="trigonal"; cmp.csystem_sub=5;
    }
    // hexagonal
    else if (s6z){ // 6
      cmp.csystem="hexagonal"; cmp.csystem_sub=1;
    }
    else if (sbar6z){// bar(6)
      cmp.csystem="hexagonal"; cmp.csystem_sub=2;
    }
    else if (s6z && smz){ // 6/m
      cmp.csystem="hexagonal"; cmp.csystem_sub=3;
    }
    else if (s6z && (s2x && s2dh2 && s2dh3) && (s2du1 && s2du2 && s2du3)){// 622
      cmp.csystem="hexagonal"; cmp.csystem_sub=4;
    }
    else if (s6z && (smx && smdh2 && smdh3) && (smdu1 && smdu2 && smdu3)){ // 6mm
      cmp.csystem="hexagonal"; cmp.csystem_sub=5;
    }
    else if (sbar6z && (smx && smdh2 && smdh3) && (s2du1 && s2du2 && s2du3)){ // bar(6)m2
      cmp.csystem="hexagonal"; cmp.csystem_sub=6;
    }
    else if (s6z && (s2x && smx && s2dh2 && smdh2 && s2dh3 && smdh3) &&
	     (s2du1 && smdu1 && s2du2 && smdu2 && s2du3 && smdu3)){ // 6/m 2/m 2/m
      cmp.csystem="hexagonal"; cmp.csystem_sub=7;
    }
    // monoclinic
    else if (s2z && s2y==0 && s2x==0){ // 2
      cmp.csystem="monoclinic"; cmp.csystem_sub=1;
    }
    else if (s2y && s2z==0 && s2x==0){ // 2
      cmp.csystem="monoclinic"; cmp.csystem_sub=2;
    }
    else if (s2x && s2y==0 && s2z==0){ // 2
      cmp.csystem="monoclinic"; cmp.csystem_sub=3;
    }
    else if (smz && smy==0 && smx==0){ // m
      cmp.csystem="monoclinic"; cmp.csystem_sub=4;
    }
    else if (smy && smz==0 && smx==0){ // m
      cmp.csystem="monoclinic"; cmp.csystem_sub=5;
    }
    else if (smx && smy==0 && smz==0){ // m
      cmp.csystem="monoclinic"; cmp.csystem_sub=6;
    }
    else if (s2z && smz && s2y==0 && smy==0 && s2x==0 && smx==0){ // 2/m
      cmp.csystem="monoclinic"; cmp.csystem_sub=7;
    }
    else if (s2y && smy && s2z==0 && smz==0 && s2x==0 && smx==0){ // 2/m
      cmp.csystem="monoclinic"; cmp.csystem_sub=8;
    }
    else if (s2x && smx && s2y==0 && smy==0 && s2z==0 && smz==0){ // 2/m
      cmp.csystem="monoclinic"; cmp.csystem_sub=9;
    }
    // triclinic
    else if (sinv){ // bar(1)
      cmp.csystem="triclinic"; cmp.csystem_sub=1;
    }
    else {
      cmp.csystem="unknown"; cmp.csystem_sub=0;
    }





    cout << "crystal system " << cmp.csystem << " subclass " << cmp.csystem_sub << endl;





    // Copy back:
    cmplist[ic] = cmp;

  }




}




